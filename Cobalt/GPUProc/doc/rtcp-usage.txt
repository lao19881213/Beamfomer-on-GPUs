===========================
Installation
===========================

To build and install Cobalt:

  # check out code from svn (here we assume a trunk-build)
  ROOT=`pwd`
  svn co -N https://svn.astron.nl/LOFAR/trunk LOFAR
  cd $ROOT/LOFAR
  svn up RTCP CMake LCS

  # Set up a config variants file for your system. This is only needed if
  # packages like casacore and DAL are installed in a non-standard
  # directory. There are variants files for the hosts cbtXXX, lhn001, and fs5
  # already. See for example: $ROOT/LOFAR/CMake/variants/variants.cbt001

  # configure Cobalt
  mkdir -p $ROOT/build/gnu_opt
  cd $ROOT/build/gnu_opt
  cmake $ROOT/LOFAR -DBUILD_PACKAGES=Cobalt \
    -DUSE_CUDA=ON -DUSE_OPENMP=ON -DUSE_MPI=ON

  # build and install into $ROOT/build/gnu_opt/installed/
  # Note: you can choose another install directory by setting the *CMake*
  # option CMAKE_INSTALL_PREFIX=</path/to/installed/software>
  make -j 16 install

  # run the test suite (optional; some tests require data sets, MPI, an sshd
  # at port 22, etc)
  ctest -j 16

  # set LOFARROOT and a few other variables for the installed build
  . $ROOT/build/gnu_opt/installed/lofarinit.sh
  (or if you use a C-shell: . $ROOT/build/gnu_opt/installed/lofarinit.csh )

  # Post-install, you'll have to create two directories, where runtime log files
  # and the like will be stored.

  mkdir -p $LOFARROOT/var/{run,log}

Those who have access to the LOFAR Operations Wiki can find extensive
information on building the LOFAR software on the following pages:

* CMake for LOFAR:
  http://www.lofar.org/wiki/doku.php?id=engineering:software:lofar-cmake
* The LOFAR Subversion Repository
  http://www.lofar.org/wiki/doku.php?id=engineering:software:lofarsvn

=============================
Running an observation
=============================

Every observation is represented by a parset file. To execute the commands
below, export $PARSET to the right file. The parset is either generated by the
Radio Observatory software (the Scheduler), or hand crafted.

startBGL.sh/stopBGL.sh
------------------------------

The scripts startBGL.sh and stopBGL.sh are used by MAC to start and stop
specific observations. Both commands are expected to return immediately, and to
save output in log files. The syntax is:

  startBGL.sh 1 2 3 $PARSET $OBSID
  stopBGL.sh 1 $OBSID

The first (few) parameters of the scripts are actually unused, and remain for
backward compatibility.

The startBGL script will:

* Augment the parset with keys from $LOFARROOT/etc/parset-additions.d/*
* Start the observation in the background by calling runObservation.sh
* Redirect output to $LOFARROOT/var/log/rtcp-$OBSID.log
* Keep track of the PID for stopBGL.sh

runObservation.sh
------------------------------

The runObservation.sh script runs an observation in the foreground, and does
everything MAC expects from an observation. The syntax is:

  runObservation.sh $PARSET

The runObservation script will:

* Start the observation in the foreground by calling mpirun.sh
  This can be forced onto localhost with (e.g. 4) MPI nodes by passing the
  '-l 4' option.
* Copy the Observation$OBSID_feedback file to the OnlineControl server (ccu001)
* Report ABORT or FINISHED to OnlineControl
  The latter two actions can be surpressed by passing the '-F' option.

mpirun.sh
------------------------------

The Cobalt software is started by calling the `rtcp' executable with the parset.
If MPI is to be used:

   mpirun.sh -x LOFARROOT=$LOFARROOT -H `mpi_node_list -n $PARSET` \
             `which rtcp` $PARSET

Note that:

  * The mpi_node_list utility extracts the list of hosts that rtcp should run
    on. More specifically, it extracts the Cobalt.Hardware.Node[x].host keys and
    joins them with commas.
  * LOFARROOT is propagated, to make sure that rtcp can find the installation.
  * `which rtcp` expands "rtcp" into its full path, preventing the $PATH in the
    login shell from redirecting to a different executable.

If MPI is not to be used:

   rtcp $PARSET

Command line parameters include:
  -p            Enable profiling. This enforces:
                    - Sequential kernel execution
                    - One SubbandProc/GPU (no overlap between kernels and GPU
                      transfers)
                    - Collect performance statistics

===========================
Configuration
===========================

The sections below will describe key parset parameters that configure the
input/output of Cobalt:

  * The mapping of stations to antenna fields
  * The selection of Cobalt hardware to use
  * The configuration of each antenna field
  * The configuration of output

The Station Set
===========================

The key

  Observation.VirtualInstrument.stationList

contains the list of stations used in the observation. Together with the key

  Observation.antennaSet

a list of antenna fields is made. For core stations (CSxxx):

  station              antennaSet             fields added
  ----------------------------------------------------------
  CSxxx                LBA                    CSxxxLBA
  CSxxx                HBA_JOINED             CSxxxHBA

  CSxxx                HBA_ZERO               CSxxxHBA0
  CSxxx                HBA_ONE                CSxxxHBA1
  CSxxx                HBA_DUAL               CSxxxHBA0 and CSxxxHBA1

for remote and international stations:

  station              antennaSet             fields added
  ----------------------------------------------------------
  xxxxx                LBA                    xxxxxLBA
  xxxxx                HBA_JOINED             xxxxxHBA

  xxxxx                HBA_ZERO               xxxxxHBA
  xxxxx                HBA_ONE                xxxxxHBA
  xxxxx                HBA_DUAL               xxxxxHBA

The Hardware Node list
=============================

The list

  Cobalt.Hardware.nrNodes = x
  Cobalt.Hardware.Node[y]
  
should be added to a parset, which bind MPI rank x to hardware (including
stations that send to that rank). MPI ranks not mentioned in the list use the
default configuration. Each node contains:

  Cobalt.Hardware.Node[rank].host
    Type:    string
    Default: (none)
    Typical: cbm001..cbm009

    Host name to run on.

  Cobalt.Hardware.Node[rank].cpu
    Type:    integer
    Default: 0
    Typical: 0, 1
  
    Socket/NUMA node number to bind to. To print the list of available sockets:
        lscpu -p=socket | sort | grep -v ^# | uniq

  Cobalt.Hardware.Node[rank].gpus
    Type:    list of integers
    Default: [0]
    Typical: [0,1] or [2,3]

    GPUs to use. (0..3). GPUs are ordered by PCI ID in ascending order.
    To print the list of available GPUs:
        lspci | grep NVIDIA | nl -v 0

  Cobalt.Hardware.Node[rank].nic
    Type:    string
    Default: ""
    Typical: mlx4_0, mlx4_1
    
    Network Interface to bind to. "" = bind to all.
    To print the list of InfiniBand devices:
        ibstatus

  Cobalt.Hardware.Node[rank].stations
    Type:    list of strings
    Default: []
    Typical: ["CS001LBA", "CS001HBA0", "CS001HBA"]
    
    Antenna fields that are received on this rank. This list is allowed to
    contain fields that are not part of the observation.

    Antenna fields not mentioned in the hardware list are distributed
    round-robin over the MPI ranks.

    Note that this key needs to be compatible with the
    PIC.Core.Station.xxxxx.RSP.ports keys below, which specify from which
    streams data should be read for the individual boards.

Antenna field configuration
===========================

Input Streams
-------------------------------

Each station send data from one or two antenna fields. Each antenna field sends
data over 1 to 4 RSP boards.

Each antenna field needs several keys. We'll use CS001LBA as an example. First,
the input:

  PIC.Core.Station.CS001LBA.RSP.ports = [udp:0.0.0.0:10000, udp:0.0.0.0:10001,
                                         udp:0.0.0.0:10002, udp:0.0.0.0:10003]

configures the CS001LBA antenna field to receive beamlets from 4 RSP boards on
the given ports.  The host on which the antenna field is received is configured
in the Cobalt.Hardware.Node list.

Beamlet <-> Subband mapping
-------------------------------

Each RSP board emits UDP packets that contain slots ("beamlets") that are
capable of carrying subband data. The following table shows the number of
beamlets per board in each bit mode:

  bitsPerSample      nrBeamletsPerBoard
  ----------------------------------------
  16                 61
  8                  122
  4                  244

The list of subbands used in the observation are mapped onto the beamlets
through the generic defaults

  Observation.rspBoardList
  Observation.rspSlotList

or the per-station configuration

  Observation.Dataslots.CS001LBA.RSPBoardList
  Observation.Dataslots.CS001LBA.DataslotList

For example, if an observation has 244 subbands in 16-bit mode, a typical
configuration is

  Observation.rspBoardList = [62*0, 62*1, 62*2, 62*3]
  Observation.rspSlotList  = [0..61, 0..61, 0..61, 0..61]

that is, subband N is received on board Observation.rspBoardList[N] in beamlet
Observation.rspSlotList[N].

Tuning keys
-------------------------------

The following keys can be configured to tune each antenna field or station:

  PIC.Core.CS001LBA.clockCorrectionTime
    Type:    double
    Default: 0.0
    Unit:    s
    
    Clock offset to correct for. Used if the clock of the antenna field
    is wrong with a known offset.

  PIC.Core.CS001LBA.phaseCenter
    Type:    [double, double, double]
    Default: (none)
    Unit:    ITRF

    Coordinates for which the data has been corrected for by the station.
    Typically a position at or near the center of the field.

  PIC.Core.CS001LBA.phaseCorrection.X
  PIC.Core.CS001LBA.phaseCorrection.Y
    Type:    double
    Default: 0.0
    Unit:    rad

    Fixed phase offset for either polarisation (frequency independent).

  PIC.Core.CS001LBA.delayCorrection.X
  PIC.Core.CS001LBA.delayCorrection.Y
    Type:    double
    Default: 0.0
    Unit:    s

    Fixed delay offset for either polarisation (frequency dependent).

The Output Configuration
===========================

The output is separated per data product. We output the following products:
  - Beamformed
  - Correlated

If we take Correlated as an example, the following keys are relevant:

  Observation.DataProducts.Output_Correlated.filenames
    Type:    list of string
    Default: []
    
    The filename for each data product.

  Observation.DataProducts.Output_Correlated.locations
    Type:    list of string
    Default: []
    
    The location for each data product. Format:
      host:directory

    If 'host' is empty:
      * the data is written to disk directly (not sent to OutputProc)
      * no header is written

    This means that an empty host is different from 'localhost'!

Note that both lists need enough entries, that is, the same or more than
the number of files produced in the observation for the given data product:

  1. Beamformed: each TAB has its own files, one per Stokes.
  2. Correlated: each subband has its own file.

